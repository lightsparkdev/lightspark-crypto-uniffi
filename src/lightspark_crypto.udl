namespace lightspark_crypto {
};

[Error]
enum LightsparkSignerError {
  "Bip32Error",
  "TweakMustHaveBoth",
  "KeyTweakError",
  "EntropyLengthError",
};

interface Mnemonic {
    constructor();

    [Name="from_entropy", Throws=LightsparkSignerError]
    constructor(sequence<u8> entropy);

    [Name="from_phrase", Throws=LightsparkSignerError]
    constructor(string phrase);

    string as_string();
};

interface Seed {
    constructor(sequence<u8> seed);

    [Name="from_mnemonic"]
    constructor([ByRef] Mnemonic mnemonic);

    sequence<u8> as_bytes();
};

interface LightsparkSigner {
    constructor([ByRef] Seed seed);

    [Throws=LightsparkSignerError]
    string get_master_public_key();

    [Throws=LightsparkSignerError]
    string derive_public_key(string derivation_path);

    [Throws=LightsparkSignerError]
    sequence<u8> ecdh(string public_key);

    sequence<u8> sign_invoice(string unsigned_invoice);

    [Throws=LightsparkSignerError]
    sequence<u8> derive_key_and_sign(
        sequence<u8> message,
        string derivation_path,
        sequence<u8>? add_tweak,
        sequence<u8>? mul_tweak
    );

    sequence<u8> get_per_commitment_point(u64 channdl_id, u64 per_commitment_point_idx);
    sequence<u8> build_commitment_secret(u64 channdl_id, u64 per_commitment_point_idx);
};